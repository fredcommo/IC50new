setClass('npl', representation(x='vector', y='vector', useLog='logical',
yProp='vector', npars='numeric', LPweight='numeric',
yFit='vector', xCurve='vector', yCurve='vector',
inflPoint='data.frame', goodness='numeric', stdErr='numeric',
pars='data.frame', estimates='data.frame', AUC='data.frame',
PL='ANY', SCE='ANY'))
# # Constructor
.nplObj = function(x=x, y=y, useLog=TRUE, yProp=NA, npars=0, LPweight=0, yFit=NA,
xCurve=NA, yCurve=NA, inflPoint=data.frame(), goodness=0, stdErr=0, pars=data.frame(),
estimates=data.frame(), AUC=data.frame(), PL=NULL, SCE=NULL){
new('npl', x=x, y=y, useLog=useLog, yProp=yProp, npars=npars, LPweight=LPweight,
yFit=yFit, xCurve=xCurve, yCurve=yCurve, inflPoint=inflPoint, goodness=goodness, stdErr=stdErr,
pars=pars, estimates=estimates, AUC = AUC, PL=PL, SCE=SCE)
}
# # setGenerics
setGeneric("getX", function(object) standardGeneric("getX"))
setGeneric("getY", function(object) standardGeneric("getY"))
setGeneric("getYProp", function(object) standardGeneric("getYProp"))
setGeneric("getFitValues", function(object) standardGeneric("getFitValues"))
setGeneric("getXcurve", function(object) standardGeneric("getXcurve"))
setGeneric("getYcurve", function(object) standardGeneric("getYcurve"))
setGeneric("getPar", function(object) standardGeneric("getPar"))
setGeneric("getInflexion", function(object) standardGeneric("getInflexion"))
setGeneric("getGoodness", function(object) standardGeneric("getGoodness"))
setGeneric("getStdErr", function(object) standardGeneric("getStdErr"))
setGeneric("getEstimates", function(object) standardGeneric("getEstimates"))
setGeneric("getAUC", function(object) standardGeneric("getAUC"))
#setGeneric("show", valueClass="npl", function(object) standardGeneric("show"))
# # Methods
setMethod("getX", "npl", function(object) return(object@x))
setMethod("getY", "npl", function(object) return(object@y))
setMethod("getYProp", "npl", function(object) return(object@yProp))
setMethod("getFitValues", "npl", function(object) return(object@yFit))
setMethod("getXcurve", "npl", function(object) return(object@xCurve))
setMethod("getYcurve", "npl", function(object) return(object@yCurve))
setMethod("getInflexion", "npl", function(object) return(object@inflPoint))
setMethod("getPar", "npl", function(object){return(list(npar=object@npars, params=object@pars))})
setMethod('getGoodness', 'npl', function(object) return(object@goodness))
setMethod('getStdErr', 'npl', function(object) return(object@stdErr))
setMethod('getEstimates', 'npl', function(object){
estim <- object@estimates
return(estim[order(estim$Surv, decreasing = TRUE),])
})
setMethod("getAUC", "npl", function(object) return(object@AUC))
setMethod("predict", "npl", function(object, target){
if(target<0 | target>1)
stop("The target value has to be between 0 and 1 (fraction of y)")
pars <- getPar(object)
estim <- .estimateRange(target, getStdErr(object), pars$params, 1e4, object@useLog)
estim <- as.data.frame(t(estim))
colnames(estim) <- c('xmin', 'x', 'xmax')
return(estim)
})
setMethod("plot", signature = "npl",
function(object, x=NA, y=NA, pcol="aquamarine1", lcol="red3", cex=1.5,
showTarget=.5, showGOF=TRUE, showIC=TRUE, B=1e4, unit='',
Title=NA, xlab='Log10(Drug[c])', ylab='Survival',...){
op <- par(no.readonly = TRUE)
par(las = 1, cex.axis = 1.5, cex.lab = 1.75, mar = c(6.5, 5.5, 4, 2), mgp = c(3.5, 1, 0))
x <- getX(object)
y <- getY(object)
newx <- getXcurve(object)
newy <- getYcurve(object)
my <- as.numeric(by(y, x, mean, na.rm=TRUE))
mx <- unique(x)
r2adj <- round(getGoodness(object), 3)
plot(x, y, col=pcol, cex=cex, pch=19, #ylim=range(min(newy, 0)-.05, max(newy, 1)+.05)*1.2,
xlab=xlab, ylab=ylab)#,...)
points(x, y, pch = 1, cex = cex)
if(showGOF)
legend(ifelse(newy[length(newy)]<newy[1], 'topright', 'bottomright'),
legend = paste('Goodness of fit:', r2adj), bty = 'n', cex = 1.5)
#            if(!is.na(showTarget)){
if(!(!showTarget)){
stdErr <- getStdErr(object)
estim <- .estimateRange(showTarget, stdErr, getPar(object)$params, B, object@useLog)
legend1 <- sprintf("IC%d : %s%s", showTarget*100, format(estim[2], scientific=TRUE), unit)
legend2 <- sprintf("[%s, %s]", format(estim[1], scientific=TRUE), format(estim[3], scientific=TRUE))
legend(ifelse(newy[length(newy)]<newy[1], 'bottomleft', 'topleft'),
legend = c(legend1, legend2), cex = 1.5, text.col = 'steelblue4', bty = 'n')
}
if(showIC){
bounds <- .IClm(getStdErr(object), getY(object), getFitValues(object), newy)
xx <- c(newx, rev(newx))
yy <- c(bounds$lo, rev(bounds$hi))
polygon(xx, yy, border = NA, col = rgb(.8,.8,.8,.4))
}
lines(newy ~ newx, col=lcol, lwd=4)#,...)
if(object@LPweight != 0){
Sub = sprintf("Weighted %s-P logistic regr. (DoseResp package, version v.1)", object@npars)
} else{
Sub = sprintf("Non-weighted %s-P logistic regr. (DoseResp package, version v.1)", object@npars)
}
title (main = Title, sub = Sub, cex.sub = .75)
par(op)
}
)
setMethod('show', 'npl',
function(object){
cat("Instance of class npl\n")
cat("\n")
cat(sprintf("%s-P logistic model\n", object@npars))
cat("Goodness of fit:", getGoodness(object), "\n")
cat("Standard error:", getStdErr(object), "\n")
cat("\n")
cat("Estimated values:\n")
show(getEstimates(object))
}
)
Logistic <- function(x, y, T0=NA, Ctrl=NA, isProp=TRUE, useLog=TRUE, LPweight=0.25,
npars="all", method=c("res", "sdw", "Y2", "pw", "gw"),...){
method <- match.arg(method)
if(is.numeric(npars) & (npars<2 | npars>5))
stop("\nThe number of parameters (npars) has to be in [2, 5]!\n
Choose 'all' to test both.\n")
if(any(is.na(x) | is.na(y))){
NAs <- union(which(is.na(x)), which(is.na(y)))
x <- x[-NAs]
y <- y[-NAs]
}
if(useLog) x <- log10(x)
object <- .nplObj(x=x, y=y, useLog=useLog, LPweight=LPweight)
if(!isProp){
object@yProp <- .survProp(y, T0, Ctrl)
} else {
object@yProp <- y
}
weights <- rep(1, length(y))
.sce <- .chooseSCE(method)
if(npars=="all"){
npars <- .testAll(.sce, x, y, weights, LPweight)
cat(sprintf("%s-Parameters model seems to have better performances.\n", npars))
}
PL <- .chooseModel(npars)
inits <- .initPars(x, y, npars)
best <- nlm(f=.sce, p=inits, x=x, yobs=y, Weights=weights, wcoef=LPweight, PL)
# Best estimates
bottom <- best$estimate[1]
top <- best$estimate[2]
xmid<-best$estimate[3]
scal <- best$estimate[4]
s <- best$estimate[5]
# Estimating values
newX <- seq(min(x), max(x), length=200)
newY <- PL(bottom, top, xmid, scal, s, newX)
yFit <- PL(bottom, top, xmid, scal, s, x)
perf <- .getPerf(y, yFit)
# Compute simulations to estimate the IC50 conf. interval
pars <- cbind.data.frame(bottom=bottom, top=top, xmid=xmid, scal=scal, s=s)
targets <- seq(.1, .9, by = .1)
estimates <- lapply(targets, function(target){.estimateRange(target, perf$stdErr, pars, 1e4, object@useLog)})
estimates <- cbind.data.frame(Resp = targets, do.call(rbind, estimates))
colnames(estimates) <- c('Surv', 'Dmin', 'D', 'Dmax')
# Inflexion point coordinates
infl <- .inflPoint(pars)
object@npars <- npars
object@pars <- pars
object@yFit <- yFit
object@xCurve <- newX
object@yCurve <- newY
object@inflPoint <- infl
object@goodness <- perf$goodness
object@stdErr <- perf$stdErr
object@estimates <- estimates
object@AUC <- data.frame(trapezoide = .AUC(newX, newY), Simpson = .Simpson(newX, newY))
object@PL <- PL
object@SCE <- .sce
return(object)
}
# model5P <- function(x, y, sd=NULL, W.coef=0.25, Plot=FALSE, Title="", Xlab="", Ylab="", pCol = "indianred2", lCol = "royalblue3", Sub = "Weighted 5P logistic regr.", ...){
.PL5 <- function(bottom, top, xmid, scal, s,  X){
yfit <- bottom+(top-bottom)/(1+10^((xmid-X)*scal))^s
return(yfit)
}
.PL4 <- function(bottom, top, xmid, scal, s,  X){
yfit <- bottom+(top-bottom)/(1+10^((xmid-X)*scal))
return(yfit)
}
.PL3 <- function(bottom, top, xmid, scal, s,  X){
yfit <- (top)/(1+10^((xmid-X)*scal))
return(yfit)
}
.PL2 <- function(bottom, top, xmid, scal, s,  X){
yfit <- 1/(1+10^((xmid-X)*scal))
return(yfit)
}
.wsqRes <- function(pars, x, yobs, Weights, wcoef, PL) {
bottom <- pars[1]
top <- pars[2]
xmid <- pars[3]
scal <- pars[4]
s <- pars[5]
ytheo <- PL(bottom, top, xmid, scal, s, x)
residuals <- (yobs - ytheo)^2
Weights <- (1/residuals)^(wcoef)
return(sum(Weights*(yobs - ytheo)^2))
}
.Y2 <- function(pars, x, yobs, Weights, wcoef, PL){
bottom <- pars[1]
top <- pars[2]
xmid <- pars[3]
scal <- pars[4]
s <- pars[5]
ytheo <- PL(bottom, top, xmid, scal, s, x)
residuals <- (yobs - ytheo)^2
return(sum(residuals/ytheo^2))
}
.poissonWeight <- function(pars, x, yobs, Weights, wcoef, PL){
bottom <- pars[1]
top <- pars[2]
xmid <- pars[3]
scal <- pars[4]
s <- pars[5]
ytheo <- PL(bottom, top, xmid, scal, s, x)
residuals <- (yobs - ytheo)^2
return(sum(residuals/abs(ytheo)))
}
.generalWeight <- function(pars, x, yobs, Weights, wcoef, PL){
bottom <- pars[1]
top <- pars[2]
xmid <- pars[3]
scal <- pars[4]
s <- pars[5]
ytheo <- PL(bottom, top, xmid, scal, s, x)
residuals <- (yobs - ytheo)^2
return(sum(residuals/(ytheo^wcoef)))
}
.sdWeight <- function(pars, x, yobs, Weights, wcoef, PL){
bottom <- pars[1]
top <- pars[2]
xmid <- pars[3]
scal <- pars[4]
s <- pars[5]
ytheo <- PL(bottom, top, xmid, scal, s, x)
residuals <- (yobs - ytheo)^2
Weights <- as.numeric(by(yobs, x, sd))
return(sum(residuals/Weights^2))
}
.survProp <- function(y, T0 = NA, Ctrl = NA){
if(is.na(Ctrl)) Ctrl <- max(y, na.rm = TRUE)
if(is.na(T0))
return(y/Ctrl)
else return((y-T0)/(Ctrl-T0))
}
.chooseSCE <- function(method){
switch(method,
sdw = {.sce <- .sdWeight},
res = {.sce <- .wsqRes},
Y2 = {.sce <- .Y2},
pw = {.sce <- .poissonWeight},
gw = {.sce <- .generalWeight}
)
return(.sce)
}
.chooseModel <- function(npars){
switch(as.character(npars),
"2" = {PL <- .PL2},
"3" = {PL <- .PL3},
"4" = {PL <- .PL4},
"5" = {PL <- .PL5}
)
return(PL)
}
.estimScal <- function(x, y){
bottom <- min(y, na.rm=TRUE); top <- max(y, na.rm=TRUE)
z <- (y - bottom)/(top - bottom)
z[z==0] <- 0.05; z[z==1] <- 0.95
lz <- log(z/(1-z))
scal <- coef(lm(x ~ lz))[2]
if(scal>1) scal <- 1/scal
return(as.numeric(scal))
}
.initPars <- function(x, y, npars){
if(npars<4) bottom <- 0 else bottom = min(y, na.rm=TRUE)
if(npars<3) top <-1 else top = max(y, na.rm=TRUE)
xmid = (max(x)+min(x))/2
scal <- .estimScal(x, y)
return(c(bottom, top, xmid, scal, s=1))
}
.getPars <- function(model){
bottom <- model$estimate[1]
top <- model$estimate[2]
xmid<-model$estimate[3]
scal <- model$estimate[4]
s <- model$estimate[5]
return(cbind.data.frame(bottom=bottom, top=top, xmid=xmid, scal=scal, s=s))
}
.fit <- function(x, y, npars, PL, .sce, LPweight){
best <- nlm(f=.sce, p=.initPars(x, y, npars), x=x, yobs=y, Weights=rep(1, length(x)), wcoef=LPweight, PL)
pars <- best$estimate
return(PL(pars[1], pars[2], pars[3], pars[4], pars[5], unique(x)))
}
.inflPoint <- function(pars){
x = pars$xmid + (1/pars$scal)*log10(pars$s)
y = pars$bottom + (pars$top - pars$bottom)*(pars$s/(pars$s+1))^pars$s
return(cbind.data.frame(x=x, y=y))
}
.getPerf <- function(y, yfit){
#  y <- scale(y); yFit <- scale(yFit)
lmtest <- summary(lm(y ~ yfit))
fstat <- lmtest$fstatistic
p <- pf(fstat[1], fstat[2], fstat[3], lower.tail=FALSE)
goodness <- lmtest$adj.r.squared
stdErr <- sqrt(1/(length(yfit)-2)*sum((yfit-y)^2))
return(cbind.data.frame(goodness=goodness, stdErr=stdErr, p=p))
}
.testAll <- function(.sce, x, y, weights, LPweight){
cat("Testing pars\n")
err <- sapply(1, function(p){
test2 <- try(nlm(f=.sce, p=.initPars(x, y, 2), x=x, yobs=y, Weights=weights, wcoef=LPweight, .PL2), silent=TRUE)
test3 <- try(nlm(f=.sce, p=.initPars(x, y, 3), x=x, yobs=y, Weights=weights, wcoef=LPweight, .PL3), silent=TRUE)
test4 <- try(nlm(f=.sce, p=.initPars(x, y, 4), x=x, yobs=y, Weights=weights, wcoef=LPweight, .PL4), silent=TRUE)
test5 <- try(nlm(f=.sce, p=.initPars(x, y, 5), x=x, yobs=y, Weights=weights, wcoef=LPweight, .PL5), silent=TRUE)
scores <- sapply(list(test2, test3, test4, test5), function(t){
if(class(t)!="try-error") return(t$minimum)
else return(Inf)
})
return(scores)
})
return(which.min(err) + 1)
}
.AUC <- function(x, y){
auc <- lapply(2:length(x), function(i){
da <- x[i]-x[i-1]
db <- y[i]-y[i-1]
y[i]*da +1/2*db*da
})
return(do.call(sum, auc))
}
.Simpson <- function(x, y){
dx <- mean(diff(x, lag = 1), na.rm = TRUE)
n <- length(y)
if(n%%2 != 0){
x <- x[-n]
y <- y[-n]
n <- length(x)
}
f1 <- y[1]
fn <- y[n]
fy <- y[2:(n-1)]*rep(c(4, 2), (n-2)/2)
return(dx/3*(f1 + sum(fy) + fn))
}
.IClm <- function(stdErr, yobs, yfit, newy){
n <- length(yobs)
ybar <- mean(yobs, na.rm = TRUE)
t <- qt(.975, n-2)
IC <- t*stdErr*sqrt((1/n+(newy - ybar)^2/sum((newy - ybar)^2)))
lo <- newy - IC
hi <- newy + IC
return(list(lo = lo, hi = hi))
}
.invModel <- function(pars, target){
#   if(any(target>=pars$top))
#     target[target>=pars$top] <- pars$top - abs(pars$top*.01)
#   if(any(target<pars$bottom))
#     target[target<=pars$bottom] <- pars$bottom + abs(pars$bottom*.01)
return(pars$xmid - 1/pars$scal*log10(((pars$top - pars$bottom)/(target - pars$bottom))^(1/pars$s)-1))
}
.estimateRange <- function(target, stdErr, pars, B, useLog){
target <- pars$bottom + (pars$top - pars$bottom)*target
Xtarget = .invModel(pars, target)
if(is.na(Xtarget)) Dmin <- D <- Dmax <- NA
else{
Ytmp <- target + rnorm(B, 0, stdErr)
if(any(Ytmp<=0)) Ytmp <- Ytmp[-Ytmp<=0]
estimate <- .invModel(pars, Ytmp)
Q <- quantile(estimate, probs=c(.025, .5, .975), na.rm=T)
if(useLog) Q <- 10^Q
Dmin <- signif(Q[1], 2)
D <- signif(Q[2], 2)
Dmax <- signif(Q[3], 2)
}
return(as.numeric(c(Dmin, D, Dmax)))
}
# demo3: proliferation curve
set.seed(12346)
n = 8; replic = 3
x <- rep(seq(1, 48, len=n), replic)
bottom=1; top=100; xmid=(min(x) + max(x))/2; scal=.1; s=.5
y <- .PL5(bottom, top, xmid, scal, s, x) + rnorm(n*replic, 5, 6)
test <- Logistic(x, y, isProp=FALSE, useLog=FALSE)
test
plot(test, xlab = "Time (hrs)", ylab = "Proliferation")
getInflexion(test)
?nlm
plot(getXcurve(test), getYcurve(test))
points(getInflexion(test), pch=19, cex=2, col="red")
# # Define class
setClass('npl', representation(x='vector', y='vector', useLog='logical',
yProp='vector', npars='numeric', LPweight='numeric',
yFit='vector', xCurve='vector', yCurve='vector',
inflPoint='data.frame', goodness='numeric', stdErr='numeric',
pars='data.frame', estimates='data.frame', AUC='data.frame',
PL='ANY', SCE='ANY'))
# # Constructor
.nplObj = function(x=x, y=y, useLog=TRUE, yProp=NA, npars=0, LPweight=0, yFit=NA,
xCurve=NA, yCurve=NA, inflPoint=data.frame(), goodness=0, stdErr=0, pars=data.frame(),
estimates=data.frame(), AUC=data.frame(), PL=NULL, SCE=NULL){
new('npl', x=x, y=y, useLog=useLog, yProp=yProp, npars=npars, LPweight=LPweight,
yFit=yFit, xCurve=xCurve, yCurve=yCurve, inflPoint=inflPoint, goodness=goodness, stdErr=stdErr,
pars=pars, estimates=estimates, AUC = AUC, PL=PL, SCE=SCE)
}
# # setGenerics
setGeneric("getX", function(object) standardGeneric("getX"))
setGeneric("getY", function(object) standardGeneric("getY"))
setGeneric("getYProp", function(object) standardGeneric("getYProp"))
setGeneric("getFitValues", function(object) standardGeneric("getFitValues"))
setGeneric("getXcurve", function(object) standardGeneric("getXcurve"))
setGeneric("getYcurve", function(object) standardGeneric("getYcurve"))
setGeneric("getPar", function(object) standardGeneric("getPar"))
setGeneric("getInflexion", function(object) standardGeneric("getInflexion"))
setGeneric("getGoodness", function(object) standardGeneric("getGoodness"))
setGeneric("getStdErr", function(object) standardGeneric("getStdErr"))
setGeneric("getEstimates", function(object) standardGeneric("getEstimates"))
setGeneric("getAUC", function(object) standardGeneric("getAUC"))
#setGeneric("show", valueClass="npl", function(object) standardGeneric("show"))
# # Methods
setMethod("getX", "npl", function(object) return(object@x))
setMethod("getY", "npl", function(object) return(object@y))
setMethod("getYProp", "npl", function(object) return(object@yProp))
setMethod("getFitValues", "npl", function(object) return(object@yFit))
setMethod("getXcurve", "npl", function(object) return(object@xCurve))
setMethod("getYcurve", "npl", function(object) return(object@yCurve))
setMethod("getInflexion", "npl", function(object) return(object@inflPoint))
setMethod("getPar", "npl", function(object){return(list(npar=object@npars, params=object@pars))})
setMethod('getGoodness', 'npl', function(object) return(object@goodness))
setMethod('getStdErr', 'npl', function(object) return(object@stdErr))
setMethod('getEstimates', 'npl', function(object){
estim <- object@estimates
return(estim[order(estim$Surv, decreasing = TRUE),])
})
setMethod("getAUC", "npl", function(object) return(object@AUC))
setMethod("predict", "npl", function(object, target){
if(target<0 | target>1)
stop("The target value has to be between 0 and 1 (fraction of y)")
pars <- getPar(object)
estim <- .estimateRange(target, getStdErr(object), pars$params, 1e4, object@useLog)
estim <- as.data.frame(t(estim))
colnames(estim) <- c('xmin', 'x', 'xmax')
return(estim)
})
setMethod("plot", signature = "npl",
function(object, x=NA, y=NA, pcol="aquamarine1", lcol="red3", cex=1.5,
showTarget=.5, showGOF=TRUE, showIC=TRUE, showInfl=FALSE, B=1e4, unit='',
Title=NA, xlab='Log10(Drug[c])', ylab='Survival',...){
op <- par(no.readonly = TRUE)
par(las = 1, cex.axis = 1.5, cex.lab = 1.75, mar = c(6.5, 5.5, 4, 2), mgp = c(3.5, 1, 0))
x <- getX(object)
y <- getY(object)
newx <- getXcurve(object)
newy <- getYcurve(object)
my <- as.numeric(by(y, x, mean, na.rm=TRUE))
mx <- unique(x)
r2adj <- round(getGoodness(object), 3)
plot(x, y, col=pcol, cex=cex, pch=19, #ylim=range(min(newy, 0)-.05, max(newy, 1)+.05)*1.2,
xlab=xlab, ylab=ylab)#,...)
points(x, y, pch = 1, cex = cex)
if(showGOF)
legend(ifelse(newy[length(newy)]<newy[1], 'topright', 'bottomright'),
legend = paste('Goodness of fit:', r2adj), bty = 'n', cex = 1.5)
#            if(!is.na(showTarget)){
if(!(!showTarget)){
stdErr <- getStdErr(object)
estim <- .estimateRange(showTarget, stdErr, getPar(object)$params, B, object@useLog)
legend1 <- sprintf("IC%d : %s%s", showTarget*100, format(estim[2], scientific=TRUE), unit)
legend2 <- sprintf("[%s, %s]", format(estim[1], scientific=TRUE), format(estim[3], scientific=TRUE))
legend(ifelse(newy[length(newy)]<newy[1], 'bottomleft', 'topleft'),
legend = c(legend1, legend2), cex = 1.5, text.col = 'steelblue4', bty = 'n')
}
if(showIC){
bounds <- .IClm(getStdErr(object), getY(object), getFitValues(object), newy)
xx <- c(newx, rev(newx))
yy <- c(bounds$lo, rev(bounds$hi))
polygon(xx, yy, border = NA, col = rgb(.8,.8,.8,.4))
}
if(showInfl)
points(getInflexion(object), pch=19, cex=2, col="blue")
lines(newy ~ newx, col=lcol, lwd=4)#,...)
if(object@LPweight != 0){
Sub = sprintf("Weighted %s-P logistic regr. (DoseResp package, version v.1)", object@npars)
} else{
Sub = sprintf("Non-weighted %s-P logistic regr. (DoseResp package, version v.1)", object@npars)
}
title (main = Title, sub = Sub, cex.sub = .75)
par(op)
}
)
setMethod('show', 'npl',
function(object){
cat("Instance of class npl\n")
cat("\n")
cat(sprintf("%s-P logistic model\n", object@npars))
cat("Goodness of fit:", getGoodness(object), "\n")
cat("Standard error:", getStdErr(object), "\n")
cat("\n")
cat("Estimated values:\n")
show(getEstimates(object))
}
)
plot(test, xlab = "Time (hrs)", ylab = "Proliferation", showInfl=TRUE)
# demo1: no replicate
set.seed(12345)
n <- 8
x <- sapply(seq(-3, 1, len=8), function(p) 10^(p))
bottom=0; top=1; xmid=(min(log10(x)) + max(log10(x)))/2; scal=-1; s=1
y <- .PL5(bottom, top, xmid, scal, s, log10(x)) + rnorm(n, 0, .05)
test <- Logistic(x, y)
test
plot(test)
plot(test, showInfl=TRUE)
setwd("~/Documents/MyProjects/FredScripts/IC50_v2/Rcode")
q()
